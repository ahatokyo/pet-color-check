<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta http-equiv="Cache-Control" content="no-store" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>愛犬パーソナルカラー診断</title>
<style>
  :root{--ink:#222;--muted:#667085;--bg:#f7f7f9;--panel:#fff;--brand:#2d9cdb}
  *{box-sizing:border-box}
  body{margin:0;font:15px/1.55 system-ui,-apple-system,"Segoe UI","Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;background:var(--bg);color:var(--ink)}
  header{padding:18px 14px;text-align:center;background:#fff;border-bottom:1px solid #eee}
  h1{margin:0 0 6px;font-size:20px}
  .subtitle{font-size:13px;color:#666;line-height:1.5}
  .app{max-width:1100px;margin:0 auto;padding:16px;display:grid;gap:14px}
  @media(min-width:900px){.app{grid-template-columns:1.2fr 1fr}}
  .card{background:var(--panel);border:1px solid #e9eaee;border-radius:12px;padding:14px}
  h2{margin:0 0 8px;font-size:16px}
  .hint{font-size:12px;color:var(--muted);display:flex;gap:6px;align-items:flex-start}
  .hint::before{content:"ⓘ";display:inline-block;line-height:1;border-radius:50%;font-size:12px;color:#4a77a8}
  .coat-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:8px}
  .coat{border:1px solid #e6e7eb;border-radius:10px;overflow:hidden;background:#fff;cursor:pointer}
  .coat .chip{height:46px}
  .coat .meta{padding:6px 8px;font-size:13px;display:flex;justify-content:space-between;align-items:center;gap:6px}
  .coat .meta span{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;flex:1;min-width:0}
  .coat small{color:#6c727f}
  .coat.selected{outline:3px solid #8ccdf5;border-color:#8ccdf5}
  .traits{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:10px}
  .group{border:1px solid #eee;border-radius:10px;padding:8px}
  .group h3{margin:0 0 6px;font-size:12px;color:var(--muted)}
  .traits-list label{display:flex;align-items:center;gap:6px;padding:3px 4px;border-radius:6px}
  .traits-list label:hover{background:#f6f7f9}
  .actions{display:flex;gap:8px;margin-top:10px}
  .btn{border:0;border-radius:999px;padding:9px 14px;font-weight:700;cursor:pointer}
  .primary{background:var(--brand);color:#fff}
  .ghost{background:#f1f3f5;color:#333}
  .err{color:#b00020;font-size:13px;margin-top:6px;display:none}
  .note{color:#b26b00;font-size:12px;margin-top:6px;display:none}
  .swatches{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
  .sw{border:1px solid #e6e6e6;border-radius:12px;overflow:hidden;background:#fff}
  .sw .chip{height:70px}
  .sw .meta{padding:8px 10px}
  .sw .ttl{font-weight:700;font-size:13px}
  .rowsm{display:flex;justify-content:space-between;align-items:center;margin-top:2px}
  .rowsm code{background:#f2f4f7;border-radius:6px;padding:2px 6px}

  /* preview section */
  #photoSection .bar{height:4px;border-radius:4px;overflow:hidden;background:#eee;margin-top:8px;display:none}
  #photoSection .bar > i{display:block;height:100%;width:0;background:var(--brand);transition:width .2s}
  #photoSection .spin{display:none;margin-top:8px;font-size:13px;color:#555}

  @media (max-width: 640px) {
    .app{grid-template-columns:1fr;padding:10px}
    .coat-grid{grid-template-columns:repeat(2,1fr);gap:10px}
    .coat .chip{height:56px}
    .coat .meta{font-size:12px;padding:5px 7px}
    .coat .meta small{display:none}
    .traits{grid-template-columns:1fr;gap:10px}
    .traits-list label{padding:8px 10px}
    .traits-list input[type="checkbox"]{transform:scale(1.25)}
    .actions{flex-direction:column;gap:10px}
    .btn{width:100%;padding:14px 16px;font-size:16px}
    .swatches{grid-template-columns:1fr;gap:12px}
    .sw .chip{height:84px}
    .sw .meta{padding:10px 12px}
    .rowsm code{font-size:12px}
    body{font-size:16px}
  }
  .coat,.btn,.traits-list label{min-height:44px}
</style>
</head>
<body>
<header>
  <h1>愛犬パーソナルカラー診断</h1>
  <div class="subtitle">合計27,000通りの毛色×性格の組み合わせから、愛犬に似合う3色を診断します</div>
</header>

<div class="app">
  <!-- 入力 -->
  <section class="card">
    <h2>1) 愛犬の毛色を選択</h2>
    <p class="hint">1色のみ選択してください。(毛が2色の場合はメインの色を選択)</p>
    <div id="coatGrid" class="coat-grid" aria-label="毛色一覧"></div>

    <h2 style="margin-top:14px">2) 愛犬の性格を1～3つまで選択</h2>
    <p class="hint">各カテゴリーから1つずつ選ぶことも、1つのカテゴリーから3つ選ぶこともできます</p>
    <div class="traits">
      <div class="group"><h3>内向的</h3><div id="traits-intro" class="traits-list"></div></div>
      <div class="group"><h3>中立的</h3><div id="traits-neutral" class="traits-list"></div></div>
      <div class="group"><h3>外交的</h3><div id="traits-extro" class="traits-list"></div></div>
    </div>

    <div class="actions">
      <button class="btn primary" id="run">診断する</button>
      <button class="btn ghost" id="reset">リセット</button>
    </div>
    <div id="msg" class="err"></div>
    <div id="note" class="note">性格は1〜3つまで選択してください。</div>
  </section>

  <!-- 結果 -->
  <section class="card">
    <h2>愛犬パーソナルカラー診断結果</h2>
    <p class="hint">メイン：毛色ベース / サブ：性格も加味 / アクセント：コントラスト重視</p>
    <div class="swatches">
      <div class="sw"><div class="chip" id="mainChip" style="background:#fff"></div><div class="meta"><div class="ttl">メイン</div><div class="rowsm"><span id="mainName">—</span><code id="mainHex">—</code></div></div></div>
      <div class="sw"><div class="chip" id="subChip"  style="background:#fff"></div><div class="meta"><div class="ttl">サブ</div><div class="rowsm"><span id="subName">—</span><code id="subHex">—</code></div></div></div>
      <div class="sw"><div class="chip" id="accChip"  style="background:#fff"></div><div class="meta"><div class="ttl">アクセント</div><div class="rowsm"><span id="accName">—</span><code id="accHex">—</code></div></div></div>
    </div>
  </section>
</div>

<!-- 写真プレビュー -->
<section class="card" id="photoSection" style="margin:16px auto;max-width:1100px;">
  <h2>愛犬写真の背景除去＆3色プレビュー</h2>
  <p class="hint">画像をアップロードすると背景を自動で除去し、診断の3色背景でプレビューできます</p>

  <input id="upload" type="file" accept="image/*" />
  <div id="upMsg" class="note" style="margin-top:8px;display:none;"></div>
  <div class="bar" id="bar"><i></i></div>
  <div class="spin" id="spin">処理中…</div>

  <div id="previewArea" style="display:none; margin-top:12px;">
    <div style="display:grid; gap:12px;">
      <canvas id="cvMain" width="900" height="900" style="max-width:100%;border:1px solid #eee;border-radius:8px;"></canvas>
      <canvas id="cvSub"  width="900" height="900" style="max-width:100%;border:1px solid #eee;border-radius:8px;"></canvas>
      <canvas id="cvAcc"  width="900" height="900" style="max-width:100%;border:1px solid #eee;border-radius:8px;"></canvas>
    </div>
    <div class="actions" style="margin-top:10px; display:flex; gap:8px; flex-wrap:wrap;">
      <button class="btn" id="dlMain" style="padding:10px 14px; border-radius:8px; border:1px solid #ddd;">メイン色背景をダウンロード</button>
      <button class="btn" id="dlSub"  style="padding:10px 14px; border-radius:8px; border:1px solid #ddd;">サブ色背景をダウンロード</button>
      <button class="btn" id="dlAcc"  style="padding:10px 14px; border-radius:8px; border:1px solid #ddd;">アクセント色背景をダウンロード</button>
    </div>
  </div>
</section>

<!-- ================== 診断ロジック（そのまま） ================== -->
<script>
/* ====== 70色パレット ====== */
const PALETTE=[{hex:"#F5F5DC",cat:"ベージュ",tone:"ライト",name:"ベージュVL"},{hex:"#E4CDA7",cat:"ベージュ",tone:"ライト",name:"ベージュL"},{hex:"#D2B48C",cat:"ベージュ",tone:"ミドル",name:"タン"},{hex:"#C3A276",cat:"ベージュ",tone:"ダーク",name:"キャメル"},{hex:"#FFFF99",cat:"黄色",tone:"ライト",name:"ライトイエロー"},{hex:"#FFFF00",cat:"黄色",tone:"ミドル",name:"イエロー"},{hex:"#DFFF00",cat:"黄色",tone:"ミドル",name:"ライムイエロー"},{hex:"#FFEF00",cat:"黄色",tone:"ミドル",name:"カナリア"},{hex:"#FFD166",cat:"黄色",tone:"ミドル",name:"ハニー"},{hex:"#F2C94C",cat:"黄色",tone:"ミドル",name:"ゴールデン"},{hex:"#FFBF00",cat:"オレンジ",tone:"ミドル",name:"アンバー"},{hex:"#FF7F00",cat:"オレンジ",tone:"ミドル",name:"オレンジ"},{hex:"#FF6700",cat:"オレンジ",tone:"ミドル",name:"タンジェリン"},{hex:"#FF6347",cat:"オレンジ",tone:"ミドル",name:"トマト"},{hex:"#FADADD",cat:"ピンク",tone:"ライト",name:"ローズミスト"},{hex:"#FBCEB1",cat:"ピンク",tone:"ライト",name:"ピーチ"},{hex:"#FFA8A8",cat:"ピンク",tone:"ライト",name:"ベビーピンク"},{hex:"#F88379",cat:"ピンク",tone:"ミドル",name:"コーラル"},{hex:"#E07A5F",cat:"ピンク",tone:"ミドル",name:"テラコッタP"},{hex:"#FF69B4",cat:"ピンク",tone:"ミドル",name:"ホットピンク"},{hex:"#FF4F9A",cat:"ピンク",tone:"ミドル",name:"ビビッドピンク"},{hex:"#FF00FF",cat:"ピンク",tone:"ミドル",name:"マゼンタ"},{hex:"#FF1493",cat:"ピンク",tone:"ミドル",name:"ディープピンク"},{hex:"#C21E56",cat:"赤",tone:"ミドル",name:"ルビー"},{hex:"#D81B60",cat:"赤",tone:"ミドル",name:"ラズベリー"},{hex:"#FF0000",cat:"赤",tone:"ミドル",name:"レッド"},{hex:"#800020",cat:"赤",tone:"ダーク",name:"バーガンディ"},{hex:"#98FFCC",cat:"緑",tone:"ライト",name:"ミント"},{hex:"#93C572",cat:"緑",tone:"ライト",name:"ピスタチオ"},{hex:"#00FF7F",cat:"緑",tone:"ライト",name:"スプリングG"},{hex:"#00FF00",cat:"緑",tone:"ライト",name:"ライム"},{hex:"#4CBB17",cat:"緑",tone:"ライト",name:"ケリー"},{hex:"#00A550",cat:"緑",tone:"ライト",name:"エメラルド"},{hex:"#6B8E23",cat:"緑",tone:"ミドル",name:"オリーブドラブ"},{hex:"#228B22",cat:"緑",tone:"ミドル",name:"フォレスト"},{hex:"#556B2F",cat:"緑",tone:"ミドル",name:"ダークオリーブ"},{hex:"#4B5320",cat:"緑",tone:"ダーク",name:"アーミーG"},{hex:"#AFEEEE",cat:"青",tone:"ライト",name:"パウダーブルー"},{hex:"#ADD8E6",cat:"青",tone:"ライト",name:"ライトブルー"},{hex:"#00FFFF",cat:"青",tone:"ライト",name:"シアン"},{hex:"#2D9CDB",cat:"青",tone:"ライト",name:"スカイ"},{hex:"#4682B4",cat:"青",tone:"ミドル",name:"スチール"},{hex:"#2EC4B6",cat:"青",tone:"ミドル",name:"ターコイズ"},{hex:"#1B7F79",cat:"青",tone:"ミドル",name:"ティール"},{hex:"#2F5DCC",cat:"青",tone:"ミドル",name:"ロイヤル"},{hex:"#0047AB",cat:"青",tone:"ミドル",name:"コバルト"},{hex:"#0000FF",cat:"青",tone:"ミドル",name:"ブルー"},{hex:"#1F2A44",cat:"青",tone:"ダーク",name:"ミッドナイト"},{hex:"#191970",cat:"青",tone:"ダーク",name:"ネイビー"},{hex:"#CCCCFF",cat:"紫",tone:"ライト",name:"ペールラベンダー"},{hex:"#C8A2C8",cat:"紫",tone:"ライト",name:"ライラック"},{hex:"#B57EDC",cat:"紫",tone:"ミドル",name:"ラベンダー"},{hex:"#8E4585",cat:"紫",tone:"ミドル",name:"プラム"},{hex:"#8F00FF",cat:"紫",tone:"ミドル",name:"エレクトリックP"},{hex:"#4B0082",cat:"紫",tone:"ミドル",name:"インディゴ"},{hex:"#C19A6B",cat:"ブラウン",tone:"ライト",name:"ライトブラウン"},{hex:"#B6864D",cat:"ブラウン",tone:"ライト",name:"ミドルブラウン"},{hex:"#CD7F32",cat:"ブラウン",tone:"ミドル",name:"ブロンズ"},{hex:"#A0522D",cat:"ブラウン",tone:"ミドル",name:"セピア"},{hex:"#C04000",cat:"ブラウン",tone:"ダーク",name:"ラセット"},{hex:"#722F37",cat:"ブラウン",tone:"ダーク",name:"マルーンB"},{hex:"#483C32",cat:"ブラウン",tone:"ダーク",name:"ダークトープ"},{hex:"#D6D6D6",cat:"グレー",tone:"ライト",name:"ライトグレー"},{hex:"#A9A9A9",cat:"グレー",tone:"ライト",name:"ダークグレー(明)"},{hex:"#808080",cat:"グレー",tone:"ミドル",name:"グレー"},{hex:"#696969",cat:"グレー",tone:"ミドル",name:"ディムグレー"},{hex:"#708090",cat:"グレー",tone:"ミドル",name:"スレートグレー"},{hex:"#36454F",cat:"グレー",tone:"ダーク",name:"チャコール"},{hex:"#1E1E1E",cat:"グレー",tone:"ダーク",name:"ジェット"},{hex:"#000000",cat:"グレー",tone:"ダーク",name:"ブラック"}];

/* ====== 毛色20 ====== */
const COATS=[["ホワイト","#FFFFFF"],["クリーム","#FFFDD0"],["フォーン","#C3A276"],["タン","#C49A6C"],["セーブル","#7B5B3E"],["アプリコット","#E6A571"],["イエロー","#FFD54F"],["ゴールド","#FFD700"],["レッド","#C04000"],["マホガニー","#722F37"],["マール","#7A92A6"],["ブルー","#5A7FA3"],["シルバー","#A9A9A9"],["ウルフセーブル","#8E8E86"],["グレー","#808080"],["ライトブラウン","#B6864D"],["ブラウン","#8B5A2B"],["ブリンドル","#5A4636"],["ダークチョコレート","#3A2C2A"],["ブラック","#000000"]];

/* ====== 性格 ====== */
const TRAITS={intro:["繊細","慎重","警戒心が強い","寂しがり屋","おだやか","マイペース","独立心が強い","頑固"],neutral:["賢い","集中力が高い","クール","素直","好奇心旺盛","甘えん坊","順応性が高い"],extro:["勇敢","活発","お調子者","リーダー気質","社交的"]};

/* ====== 色ユーティリティ ====== */
const hexToRgb=h=>{const m=h.replace('#','');return{r:parseInt(m.slice(0,2),16),g:parseInt(m.slice(2,4),16),b:parseInt(m.slice(4,6),16)}};
const rgbToHue=({r,g,b})=>{r/=255;g/=255;b/=255;const mx=Math.max(r,g,b),mn=Math.min(r,g,b),d=mx-mn;if(d===0)return 0;let h=mx===r?(g-b)/d:mx===g?(b-r)/d+2:(r-g)/d+4;return (h*60+360)%360};
const hueOf=hex=>rgbToHue(hexToRgb(hex));
const hueDist=(a,b)=>{const d=Math.abs(a-b)%360;return d>180?360-d:d};
function rgbToXyz(r,g,b){r/=255;g/=255;b/=255;r=r>0.04045?((r+0.055)/1.055)**2.4:r/12.92;g=g>0.04045?((g+0.055)/1.055)**2.4:g/12.92;b=b>0.04045?((b+0.055)/1.055)**2.4:b/12.92;const x=r*0.4124+g*0.3576+b*0.1805;const y=r*0.2126+g*0.7152+b*0.0722;const z=r*0.0193+g*0.1192+b*0.9505;return{x:x*100,y:y*100,z:z*100}}
function xyzToLab(x,y,z){const xr=x/95.047,yr=y/100,zr=z/108.883;const f=t=>t>0.008856?Math.cbrt(t):(7.787*t+16/116);const fx=f(xr),fy=f(yr),fz=f(zr);return{L:116*fy-16,a:500*(fx-fy),b:200*(fy-fz)}}
const hexToLab=hex=>{const {r,g,b}=hexToRgb(hex);const {x,y,z}=rgbToXyz(r,g,b);return xyzToLab(x,y,z)};
function labChroma(hex){const L=hexToLab(hex);return Math.hypot(L.a,L.b);}

/* ====== 性格→センチメント ====== */
const traitGroup={}; 
TRAITS.intro.forEach(t=>traitGroup[t]="内向");
TRAITS.neutral.forEach(t=>traitGroup[t]="中立");
TRAITS.extro.forEach(t=>traitGroup[t]="外交");
function sentiment(traits){let s=0,n=0,e=0;traits.forEach(t=>{const g=traitGroup[t];if(g==="内向")s++;else if(g==="外交")e++;else n++;});if(e>=s&&e>=n)return"外交";if(s>=n&&s>=e)return"内向";return"中立"}
const tonePrefWeight={内向:{ライト:1.0,ミドル:0.7,ダーク:0.3},中立:{ライト:0.7,ミドル:1.0,ダーク:0.7},外交:{ライト:0.4,ミドル:0.9,ダーク:1.0}};
const TRAIT_HUE_TILT={
  "繊細":[330,285], "慎重":[30,210], "警戒心が強い":[30,210],
  "寂しがり屋":[330,270], "おだやか":[90,40], "マイペース":[40,210],
  "独立心が強い":[270,210], "頑固":[20,0],
  "賢い":[210,220], "集中力が高い":[210,200], "クール":[210,240],
  "素直":[120,60], "好奇心旺盛":[60,330], "甘えん坊":[330,300],
  "順応性が高い":[40,120],
  "勇敢":[0,30], "活発":[30,60], "お調子者":[60,330],
  "リーダー気質":[270,0], "社交的":[60,30]
};
function hueBiasScore(colorHue, prefHues){ if(!prefHues || !prefHues.length) return 0; let best=0; prefHues.forEach(h=>{ const d=hueDist(colorHue,h); best=Math.max(best, Math.exp(-(d*d)/(2*25*25))); }); return best; }

/* ====== シード乱数 ====== */
function seedFrom(str){let h=2166136261>>>0;for(let i=0;i<str.length;i++){h^=str.charCodeAt(i);h=Math.imul(h,16777619);}return h>>>0}
function rng(seed){let s=seed>>>0;return ()=>{s=(s*1664525+1013904223)>>>0;return (s&0xffff)/0x10000};}

/* ====== 診断ロジック ====== */
function pickColors(coatName, traits){
  const coatHex = (new Map(COATS)).get(coatName) || "#FFFFFF";
  const coatHue = hueOf(coatHex);
  const senti = sentiment(traits);
  const r = rng(seedFrom(coatName + "|" + traits.slice().sort().join(",")));
  const favorGray = ["クール","賢い","集中力が高い"].some(t => traits.includes(t));

  const comp = (coatHue+180)%360;
  const splits = [(coatHue+150)%360,(coatHue+210)%360];
  const splitPrimary = splits[Math.floor(r()*splits.length)];

  const scored = PALETTE.map(c=>{
    const H = hueOf(c.hex), L = hexToLab(c.hex).L, C = labChroma(c.hex);
    const sAnalog = Math.exp(-(hueDist(H,coatHue)**2)/(2*35*35));
    const sComp   = Math.exp(-(hueDist(H,comp)**2)/(2*25*25));
    const sSplit1 = Math.exp(-(hueDist(H,splitPrimary)**2)/(2*22*22));
    const sSplit2 = Math.exp(-(hueDist(H,(splitPrimary===splits[0]?splits[1]:splits[0]))**2)/(2*25*25));
    const sSplit  = Math.max(sSplit1,sSplit2);

    let bias=0; traits.forEach(t=>{ bias += hueBiasScore(H, TRAIT_HUE_TILT[t]); });
    bias /= Math.max(1, traits.length);

    const toneW = (tonePrefWeight[senti][c.tone]||0.6);

    const mainScore = (1.2*sAnalog + 0.6*bias) * (0.8 + 0.4*toneW);
    const subBase   = (0.9*sAnalog + 0.9*bias) * (0.7 + 0.6*toneW);

    const grayPenalty = Math.max(0, (20 - Math.min(C,20)) / 20);
    const grayFactor =
      favorGray ? (1 - 0.25*grayPenalty) :
      senti==="外交" ? (1 - 0.35*grayPenalty) :
      senti==="中立" ? (1 - 0.55*grayPenalty) :
                       (1 - 0.70*grayPenalty);

    const accentBase =
      (senti==="外交" ? (0.9*sSplit + 1.05*sComp) :
       senti==="内向" ? (1.1*sSplit + 0.6*sComp) :
                        (1.0*sSplit + 0.8*sComp))
      + 0.55*bias;

    const wiggle = 0.96 + 0.08*r();

    return {c, H, L, mainScore, subBase, accentRaw: accentBase*grayFactor*wiggle};
  });

  // MAIN
  const mainList=[...scored].sort((a,b)=>b.mainScore-a.mainScore);
  const mTop=mainList[0].mainScore, mNear=mainList.filter(x=>x.mainScore>=mTop*0.98);
  const main=(mNear[Math.floor(r()*mNear.length)]||mainList[0]).c;

  // SUB
  const mainHue=hueOf(main.hex), mainL=hexToLab(main.hex).L;
  const subList=scored.filter(x=>x.c.hex!==main.hex).map(x=>{
      const huePenalty = Math.exp(-(hueDist(x.H, mainHue)**2)/(2*20*20));
      const lightPenalty = Math.exp(-((x.L-mainL)**2)/(2*8*8));
      const diversityPenalty = 0.35*huePenalty + 0.25*lightPenalty;
      return {x, score: x.subBase*(1 - diversityPenalty)};
    }).sort((a,b)=>b.score-a.score);
  const sTop=subList[0].score, sNear=subList.filter(s=>s.score>=sTop*0.97);
  const sub=(sNear[Math.floor(r()*sNear.length)]||subList[0]).x.c;

  // ACCENT
  const usedCats=new Set([main.cat||main.c?.cat, sub.cat||sub.c?.cat].filter(Boolean));
  const subHue=hueOf(sub.hex);
  const accentList=scored
    .filter(x=>x.c.hex!==main.hex && x.c.hex!==sub.hex)
    .map(x=>{
      const nearMain = Math.exp(-(hueDist(x.H, mainHue)**2)/(2*18*18));
      const nearSub  = Math.exp(-(hueDist(x.H, subHue )**2)/(2*18*18));
      let score = x.accentRaw * (1 - (0.35*nearMain + 0.25*nearSub));
      if(usedCats.has(x.c.cat)) score *= 0.82;
      if(x.c.cat==="青") score *= 0.93;
      if(x.c.cat==="グレー") score *= 0.85;
      return {x, score};
    })
    .sort((a,b)=>b.score-a.score);
  const aTop=accentList[0].score, aNear=accentList.filter(s=>s.score>=aTop*0.96);
  const accent=(aNear[Math.floor(r()*aNear.length)]||accentList[0]).x.c;

  return {main, sub, accent};
}

/* ====== UI描画 ====== */
const coatGrid=document.getElementById("coatGrid");
let selectedCoat=null;
function renderCoats(){
  coatGrid.innerHTML="";
  COATS.forEach(([name,hex])=>{
    const card=document.createElement("button");
    card.type="button"; card.className="coat";
    card.innerHTML=`<div class="chip" style="background:${hex}"></div>
                    <div class="meta"><span>${name}</span><small>${hex}</small></div>`;
    card.addEventListener("click",()=>{
      selectedCoat=name;
      document.querySelectorAll(".coat").forEach(c=>c.classList.remove("selected"));
      card.classList.add("selected");
    });
    coatGrid.appendChild(card);
  });
}
renderCoats();

/* 性格リスト描画＋制限（1〜3つ） */
function addTraitList(containerId, list){
  const el=document.getElementById(containerId);
  list.forEach(t=>{
    const wrap=document.createElement("label");
    const cb=document.createElement("input"); cb.type="checkbox"; cb.value=t;
    cb.addEventListener("change",limitTraits);
    wrap.appendChild(cb); wrap.appendChild(document.createTextNode(" "+t));
    el.appendChild(wrap);
  });
}
addTraitList("traits-intro", TRAITS.intro);
addTraitList("traits-neutral", TRAITS.neutral);
addTraitList("traits-extro", TRAITS.extro);

function selectedTraits(){ return [...document.querySelectorAll(".traits input[type=checkbox]:checked")].map(i=>i.value); }
function limitTraits(e){
  const checks=[...document.querySelectorAll(".traits input[type=checkbox]")];
  const checked=checks.filter(c=>c.checked);
  const note=document.getElementById("note");
  if(checked.length>3){
    e.target.checked=false;
    note.style.display="block";
    setTimeout(()=>note.style.display="none",1400);
  }
}

/* 結果描画 */
function setSw(prefix, color){
  document.getElementById(prefix+"Chip").style.background=color.hex;
  document.getElementById(prefix+"Hex").textContent=color.hex;
  document.getElementById(prefix+"Name").textContent=color.name;
}

/* 診断実行 */
function run(){
  const msg=document.getElementById("msg");
  const traits=selectedTraits();
  if(!selectedCoat){ msg.textContent="毛色を1つ選択してください。"; msg.style.display="block"; return; }
  if(traits.length===0){ msg.textContent="性格は1〜3つまで選択してください。"; msg.style.display="block"; return; }
  msg.style.display="none";
  try{
    const res=pickColors(selectedCoat, traits);
    setSw("main",res.main); setSw("sub",res.sub); setSw("acc",res.accent);
  }catch(e){
    console.error(e);
    msg.textContent="エラー：内部データに不整合があります。";
    msg.style.display="block";
  }
}
document.getElementById("run").addEventListener("click", run);

/* リセット */
document.getElementById("reset").addEventListener("click", ()=>{
  selectedCoat=null;
  document.querySelectorAll(".coat").forEach(c=>c.classList.remove("selected"));
  document.querySelectorAll(".traits input[type=checkbox]").forEach(c=>c.checked=false);
  ["main","sub","acc"].forEach(k=>{
    document.getElementById(k+"Chip").style.background="#fff";
    document.getElementById(k+"Hex").textContent="—";
    document.getElementById(k+"Name").textContent="—";
  });
  const msg=document.getElementById("msg"); msg.style.display="none";
});
</script>

<!-- ============ 写真モジュール（サーバ失敗時はローカル切り抜き） ============ -->
<script>
/*** レガシー要素掃除 ***/
document.getElementById('file')?.remove();

/*** 診断HEX ***/
function currentResultHexes(){
  const m=document.getElementById('mainHex')?.textContent.trim();
  const s=document.getElementById('subHex')?.textContent.trim();
  const a=document.getElementById('accHex')?.textContent.trim();
  if(!m||m==='—'||!s||s==='—'||!a||a==='—') return null;
  return {main:m,sub:s,acc:a};
}

/*** UI ***/
function setUpMsg(text,isErr=false){
  const el=document.getElementById('upMsg');
  el.style.display='block';
  el.style.color=isErr?'#b00020':'#b26b00';
  el.textContent=text;
}
const bar=document.getElementById('bar'); const barI=bar?.querySelector('i'); const spin=document.getElementById('spin');
function prog(p){ if(!bar||!barI) return; bar.style.display='block'; barI.style.width=(Math.max(0,Math.min(100,Number(p)||0)))+'%'; }
function spinOn(){ if(spin) spin.style.display='block'; }
function spinOff(){ if(spin) spin.style.display='none'; if(bar) bar.style.display='none'; }

/*** 画像を安全に縮小（EXIF向き考慮） ***/
async function normalizeImageFile(file, maxSide=1800){
  const opts = { imageOrientation: 'from-image', premultiplyAlpha: 'premultiply' };
  let bitmap;
  try{
    bitmap = await createImageBitmap(file, opts);
  }catch{
    const blobUrl = URL.createObjectURL(file);
    bitmap = await new Promise((res,rej)=>{
      const img=new Image(); img.onload=()=>{res(img); URL.revokeObjectURL(blobUrl);};
      img.onerror=e=>{rej(e); URL.revokeObjectURL(blobUrl);};
      img.src=blobUrl;
    });
  }

  const w = bitmap.width, h = bitmap.height;
  const scale = Math.min(1, maxSide/Math.max(w,h));
  if(scale === 1) return file;

  const targetW = Math.round(w*scale), targetH = Math.round(h*scale);
  const canvas = document.createElement('canvas');
  canvas.width = targetW; canvas.height = targetH;
  const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });
  ctx.imageSmoothingQuality = 'high';
  ctx.drawImage(bitmap, 0, 0, targetW, targetH);

  const blob = await new Promise(res => canvas.toBlob(res, 'image/jpeg', 0.92));
  return new File([blob], (file.name||'image')+'.jpg', { type:'image/jpeg', lastModified:Date.now() });
}

/*** dataURL→Blob ***/
function dataURLtoBlob(dataUrl){
  const [h,b]=dataUrl.split(','); const mime=(h.match(/data:(.*?);/)||[])[1]||'image/png';
  const bin=atob(b); const u8=new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i);
  return new Blob([u8],{type:mime});
}

/*** Blob→Image（非画像レスポンス検出） ***/
async function blobToImageOrThrow(blob){
  const type=blob.type||'';
  if(type && !type.startsWith('image/')){
    const text=await blob.text().catch(()=> '');
    throw new Error(`非画像レスポンス: ${type} / ${String(text).slice(0,300)}`);
  }
  return new Promise((resolve,reject)=>{
    const url=URL.createObjectURL(blob);
    const im=new Image();
    im.onload=()=>{ URL.revokeObjectURL(url); resolve(im); };
    im.onerror=e=>{ URL.revokeObjectURL(url); reject(e); };
    im.src=url;
  });
}

/*** fetch with timeout ***/
async function fetchWithTimeout(url,opts={},timeoutMs=15000){
  const ctl=new AbortController(); const id=setTimeout(()=>ctl.abort(),timeoutMs);
  try{ return await fetch(url,{...opts,signal:ctl.signal}); }
  finally{ clearTimeout(id); }
}

/*** /api/remove-bg にマルチ戦略で送信（成功すれば Blob を返す） ***/
async function tryServerRemoveBg(file){
  const plans=[
    async()=>({desc:'multipart[file]', req:await fetchWithTimeout('/api/remove-bg',{method:'POST',body:(()=>{const fd=new FormData(); fd.append('file',file,file.name||"image.jpg"); return fd;})()})}),
    async()=>({desc:'multipart[image]',req:await fetchWithTimeout('/api/remove-bg',{method:'POST',body:(()=>{const fd=new FormData(); fd.append('image',file,file.name||"image.jpg"); return fd;})()})}),
    async()=>({desc:'json{data}',      req:await fetchWithTimeout('/api/remove-bg',{method:'POST',headers:{'Content-Type':'application/json'},body:await (async()=>{const b64=await new Promise((r,j)=>{const fr=new FileReader(); fr.onload=()=>{try{const s=String(fr.result||''); r(JSON.stringify({filename:file.name||'image.jpg',mime:file.type||'image/jpeg',data:s.split(',')[1]||''}));}catch(e){j(e);}}; fr.onerror=j; fr.readAsDataURL(file);}); return b64;})()})}),
    async()=>({desc:'json{image_b64}', req:await fetchWithTimeout('/api/remove-bg',{method:'POST',headers:{'Content-Type':'application/json'},body:await (async()=>{const b64=await new Promise((r,j)=>{const fr=new FileReader(); fr.onload=()=>{try{const s=String(fr.result||''); r(JSON.stringify({image_b64:s.split(',')[1]||''}));}catch(e){j(e);}}; fr.onerror=j; fr.readAsDataURL(file);}); return b64;})()})}),
    async()=>({desc:'json{image:dataURL}',req:await fetchWithTimeout('/api/remove-bg',{method:'POST',headers:{'Content-Type':'application/json'},body:await (async()=>{const s=await new Promise((r,j)=>{const fr=new FileReader(); fr.onload=()=>r(String(fr.result||'')); fr.onerror=j; fr.readAsDataURL(file);}); return JSON.stringify({image:s});})()})})
  ];
  const errors=[];
  for(const plan of plans){
    let desc, res;
    try{
      ({desc,req:res}=await plan());
      if(!res.ok){ errors.push(`${desc} -> HTTP ${res.status} ${await res.text().catch(()=> '')}`); continue; }
      const ct=(res.headers.get('Content-Type')||'').toLowerCase();
      if(ct.startsWith('image/')) return await res.blob();
      if(ct.includes('application/json')){
        const j=await res.json();
        if(j.url){ const ir=await fetchWithTimeout(j.url); if(!ir.ok) throw new Error(`URL取得失敗 ${ir.status}`); return await ir.blob(); }
        if(j.pngBase64||j.base64||j.image_b64){ return dataURLtoBlob(`data:image/png;base64,${j.pngBase64||j.base64||j.image_b64}`); }
        if(j.dataUrl||j.dataURL){ return dataURLtoBlob(j.dataUrl||j.dataURL); }
        throw new Error(`未知JSON: ${Object.keys(j).join(',')}`);
      }
      // text 等
      throw new Error(`${desc} -> 非画像レスポンス ${ct} : ${(await res.text().catch(()=> '')).slice(0,200)}`);
    }catch(e){ errors.push(String(e).slice(0,200)); }
  }
  throw new Error('サーバ切り抜き 全方式失敗\n' + errors.join('\n'));
}

/*** ▼ローカル簡易切り抜き（四隅平均で背景色推定→しきい値で透明化＋フェザー） ***/
async function localQuickMatting(fileOrImage){
  // Image を得る
  const img = fileOrImage instanceof HTMLImageElement ? fileOrImage :
    await (async ()=>{ const url=URL.createObjectURL(fileOrImage); const im=new Image(); await new Promise((res,rej)=>{im.onload=()=>{URL.revokeObjectURL(url);res();}; im.onerror=e=>{URL.revokeObjectURL(url);rej(e);}; im.src=url;}); return im; })();

  const maxSide=1400; // ローカル処理は少し軽めに
  const scale=Math.min(1, maxSide/Math.max(img.width,img.height));
  const W=Math.round(img.width*scale), H=Math.round(img.height*scale);

  const cvs=document.createElement('canvas'); cvs.width=W; cvs.height=H;
  const ctx=cvs.getContext('2d');
  ctx.imageSmoothingQuality='high';
  ctx.drawImage(img,0,0,W,H);

  const {data}=ctx.getImageData(0,0,W,H);

  // 四隅5%エリアの平均色（背景想定）
  function avgRegion(x0,y0,x1,y1){
    let r=0,g=0,b=0,n=0;
    for(let y=y0;y<y1;y+=2){ // 2px 間引きで速度アップ
      let off=(y*W + x0)*4;
      for(let x=x0;x<x1;x+=2){ r+=data[off]; g+=data[off+1]; b+=data[off+2]; n++; off+=8; }
    }
    return [r/n,g/n,b/n];
  }
  const dx=Math.max(2,Math.floor(W*0.05)), dy=Math.max(2,Math.floor(H*0.05));
  const samples=[
    avgRegion(0,0,dx,dy),
    avgRegion(W-dx,0,W,dy),
    avgRegion(0,H-dy,dx,H),
    avgRegion(W-dx,H-dy,W,H)
  ];
  const bg=[0,1,2].map(i=>Math.round(samples.reduce((s,v)=>s+v[i],0)/samples.length)); // 四隅平均

  // しきい値（背景が明るい/暗いで少し調整）
  const bgL = 0.2126*bg[0]+0.7152*bg[1]+0.0722*bg[2];
  const th  = bgL>180 ? 48 : 36;     // 基本しきい値（RGB距離）
  const soft= th*1.6;                // フェザー開始

  // ピクセルごとにアルファを再計算
  for(let y=0, i=0; y<H; y++){
    for(let x=0; x<W; x++, i+=4){
      const dr=data[i]-bg[0], dg=data[i+1]-bg[1], db=data[i+2]-bg[2];
      const d=Math.sqrt(dr*dr+dg*dg+db*db);
      let a=255;
      if(d<=th){ a=0; }
      else if(d<th*1.2){ a=Math.round(255*(d-th)/(th*0.2)); }           // 0→255へ緩やかに
      else if(d<soft){ a=Math.round(255*(d-th)/(soft-th)); }            // さらにフェザー
      data[i+3]=a;
    }
  }
  ctx.putImageData(new ImageData(data,W,H),0,0);

  // 透過PNGへ
  const blob=await new Promise(res=>cvs.toBlob(res,'image/png'));
  return blob;
}

/*** 合成（中央フィット） ***/
function drawComposite(canvas,bgHex,subjectImg){
  const ctx=canvas.getContext('2d');
  const W=canvas.width,H=canvas.height;
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle=bgHex; ctx.fillRect(0,0,W,H);
  const pad=.05,maxW=W*(1-2*pad),maxH=H*(1-2*pad);
  const scale=Math.min(maxW/subjectImg.width,maxH/subjectImg.height);
  const dw=subjectImg.width*scale,dh=subjectImg.height*scale;
  const dx=(W-dw)/2,dy=(H-dh)/2;
  ctx.shadowColor='rgba(0,0,0,.15)';
  ctx.shadowBlur=Math.round(W*.02);
  ctx.drawImage(subjectImg,dx,dy,dw,dh);
  ctx.shadowBlur=0;
}

/*** DL ***/
function downloadCanvas(canvas, filename){
  const dataUrl=canvas.toDataURL('image/png');
  const isIOS=/iP(hone|ad|od)/.test(navigator.platform)||
              (navigator.userAgent.includes('Mac') && 'ontouchend' in document);
  if(isIOS){
    const w=window.open(); if(!w) return;
    w.document.write('<html><head><title>長押しで保存</title></head><body style="margin:0">');
    w.document.write(`<img src="${dataUrl}" style="width:100%;height:auto;display:block">`);
    w.document.write('</body></html>');
    w.document.close();
  }else{
    const a=document.createElement('a');
    a.href=dataUrl; a.download=filename; document.body.appendChild(a); a.click(); a.remove();
  }
}

/*** メインフロー ***/
async function processAndPreview(file){
  const hexes=currentResultHexes();
  if(!hexes){ setUpMsg('先に診断を実行して、3色を確定してください。',true); return; }
  if(!/^image\//i.test(file.type)){ setUpMsg('画像ファイルを選択してください。',true); return; }
  if(file.size>20*1024*1024){ setUpMsg('画像が大きすぎます（20MB以下推奨）',true); return; }

  try{
    setUpMsg('背景を削除中…'); prog(2); spinOn();

    // 事前縮小
    const normalized = await normalizeImageFile(file, 1800);
    prog(15);

    // まずはサーバ切り抜き
    let cutBlob;
    try{
      cutBlob = await tryServerRemoveBg(normalized);
      setUpMsg('背景除去：サーバで完了');
    }catch(serverErr){
      console.warn('server remove-bg failed, fallback to local', serverErr);
      setUpMsg('サーバ切り抜きに失敗 → ローカル簡易処理で代替します');
      // ローカル簡易切り抜き
      cutBlob = await localQuickMatting(normalized);
    }
    prog(80);

    const subject=await blobToImageOrThrow(cutBlob);
    prog(90);

    drawComposite(document.getElementById('cvMain'),hexes.main,subject);
    drawComposite(document.getElementById('cvSub'), hexes.sub ,subject);
    drawComposite(document.getElementById('cvAcc'), hexes.acc ,subject);
    prog(100);

    document.getElementById('previewArea').style.display='block';
    setUpMsg('プレビューを表示しました。各ボタンから保存できます。');
  }catch(err){
    console.error(err);
    setUpMsg('背景除去に失敗しました： '+String(err).slice(0,500), true);
  }finally{
    spinOff(); prog(0);
    setTimeout(()=>{ const el=document.getElementById('upMsg'); if(el) el.style.display='none'; }, 7000);
  }
}

/*** 入口：アップロード ***/
const uploadEl=document.getElementById('upload');
if(uploadEl){
  uploadEl.addEventListener('change', (e)=>{
    const file=e.target.files?.[0]; if(!file) return;
    processAndPreview(file);
  });
}

/*** DLボタン ***/
document.getElementById('dlMain')?.addEventListener('click',()=>downloadCanvas(document.getElementById('cvMain'),'main.png'));
document.getElementById('dlSub') ?.addEventListener('click',()=>downloadCanvas(document.getElementById('cvSub') ,'sub.png'));
document.getElementById('dlAcc') ?.addEventListener('click',()=>downloadCanvas(document.getElementById('cvAcc') ,'accent.png'));
</script>
</body>
</html>
